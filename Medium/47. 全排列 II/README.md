# 问题描述

给定一个可包含重复数字的序列，返回所有不重复的全排列。

示例:

```
输入: [1,1,2]
输出:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```

# 思路(C++)

全排列问题的扩展，在全排列的问题上考虑除重即可，即在做选择之前进行剪枝。此处使用c++11，新特性`unordered_set` 来判断当前节点所代表的元素是否已经被使用过。

### 知识点补充

- **unordered_map和map**

  unordered_map存储机制是哈希表，，即unordered_map内部元素是无序的。

  map是红黑树，map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。

- **unordered_set和set**

  unordered_set基于哈希表，是无序的。

  set实现了红黑树的平衡二叉检索树的数据结构，插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，以保证每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值；另外，还得保证根节点左子树的高度与右子树高度相等。

  平衡二叉检索树使用中序遍历算法，检索效率高于vector、deque和list等容器，另外使用中序遍历可将键值按照从小到大遍历出来。

- unordered_set和unordered_map使用

  1. 插入函数`insert()`， 特别的map的插入主要有：`maps.insert(pair<int, int> (a, b))` 和 `maps.insert(make_pair(a, b))`
  2. 查找函数`find()` ，返回一个迭代器。这个迭代器指向和参数哈希值匹配的元素，如果没有匹配的元素，会返回这个容器的结束迭代器(set.end())
  3. 删除函数`erase()` ，删除容器中和传入参数的哈希值相同的元素
  4. 数量操作`size()、empty()、count()` ，其中 `count()` 返回匹配给定主键的元素的个数（value出现的次数）
  5. ​
     函数`insert()、find()` 和 `erase()`的平均时间复杂度都是O(1)的。

## Python

待完成......

## 参考解法

待完成......